use super::ServerState;
use super::protocol::AgoraMeta;
use super::publisher_info::PublisherInfo;
use crate::ConnectionHandle;
use crate::constants::CHECK_PUBLISHER_LIVELINESS_EVERY_MS;
use crate::utils::OrError;
use std::sync::Arc;
use tokio::sync::{Mutex, RwLock};
use tokio::task::JoinHandle;

use std::net::IpAddr;
use tarpc::context;
use tarpc::server::incoming::Incoming;

use futures::prelude::*;
use tarpc::{
    server::{self, Channel},
    tokio_serde::formats::Json,
};
use tokio::time::{Duration, interval};

// Asynchronous wrapper around synchronous ServerState implementation that handles networking with defaults.
#[derive(Clone)]
pub struct AgoraMetaServer {
    state: Arc<RwLock<ServerState>>,
    bg_handle: Arc<Mutex<JoinHandle<()>>>,
}

impl AgoraMeta for AgoraMetaServer {
    async fn register_publisher(
        self,
        _: context::Context,
        name: String,
        path: String,
        host_connection: ConnectionHandle,
    ) -> OrError<PublisherInfo> {
        let mut state = self.state.write().await;
        state.register_publisher(name, path, host_connection)
    }

    async fn confirm_publisher(self, _: context::Context, path: String) -> OrError<()> {
        let mut state = self.state.write().await;
        state.confirm_publisher(path).await
    }

    async fn remove_publisher(self, _: context::Context, path: String) -> OrError<PublisherInfo> {
        let mut state = self.state.write().await;
        state.remove_publisher(path)
    }

    async fn path_tree(self, _: context::Context) -> String {
        let state = self.state.read().await;
        state.get_path_tree_repr()
    }

    async fn publisher_info(self, _: context::Context, path: String) -> OrError<PublisherInfo> {
        let mut state = self.state.write().await;
        state.get_publisher_info(path).await
    }
}

impl AgoraMetaServer {
    fn new(shared_state: Arc<RwLock<ServerState>>, bg_handle: Arc<Mutex<JoinHandle<()>>>) -> Self {
        Self {
            state: shared_state,
            bg_handle,
        }
    }

    pub async fn run_server(address: IpAddr, port: u16) -> anyhow::Result<()> {
        let server_addr = (address, port);

        // Create a single shared server state that all connections will use
        let shared_state = Arc::new(RwLock::new(ServerState::new()));

        // JSON transport is provided by the json_transport tarpc module. It makes it easy
        // to start up a serde-powered json serialization strategy over TCP.
        let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
        println!("Listening on port {}", listener.local_addr().port());
        listener.config_mut().max_frame_length(usize::MAX);

        // Start a background process to obtain write lock on shared_state and prunes. Should execute once every constant (see top) number of ms
        let pruning_state = Arc::clone(&shared_state);
        let bg_handle = Arc::new(Mutex::new(tokio::spawn(async move {
            let mut interval = interval(Duration::from_millis(CHECK_PUBLISHER_LIVELINESS_EVERY_MS));
            loop {
                interval.tick().await;
                let pruned_paths = {
                    let mut state = pruning_state.write().await;
                    state.prune_stale_publishers().await
                }; // Lock is dropped here
                if !pruned_paths.is_empty() {
                    println!("Pruned stale publishers: {:?}", pruned_paths);
                }
            }
        })));

        // Listener yields a stream of connections. Each connection is a stream of requests.
        listener
            // Ignore accept errors.
            .filter_map(|r| futures::future::ready(r.ok()))
            .map(server::BaseChannel::with_defaults)
            // An IP can register many many services.
            .max_channels_per_key(1024 * 1024, |t| t.transport().peer_addr().unwrap().ip())
            // serve is generated by the service attribute. It takes as input any type implementing
            // the generated AgoraMeta trait.
            .map(|channel| {
                // Each channel **represents a single, persistent connection to a client.**
                // BUT they all share the same server state!
                let server =
                    AgoraMetaServer::new(Arc::clone(&shared_state), Arc::clone(&bg_handle));
                channel.execute(server.serve()).for_each(
                    // Async wrapper around tokio::spawn
                    |fut| async {
                        fut.await; // Sequentially wait for each future to complete
                    },
                )
            })
            .buffer_unordered(32768)
            // for_each runs stream to completion. For this particular case, it will run forever.
            // An example stream which terminates would finite-length stream.
            .for_each(|_| async {})
            .await;

        Ok(())
    }
}

impl Drop for AgoraMetaServer {
    fn drop(&mut self) {
        // Only cleanup if this is the last reference
        if Arc::strong_count(&self.bg_handle) == 1 {
            if let Ok(handle_guard) = self.bg_handle.try_lock() {
                handle_guard.abort();
                println!("Background pruning task stopped");
            }
        }
    }
}
