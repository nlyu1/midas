use clap::Parser;
use std::net::{IpAddr, Ipv6Addr};
// "client" contains utilities like `Config`
// "context" provides request-scoped metadata.
// "tokio::serde" specifies transport format.
use tarpc::{client, context, tokio_serde::formats::Json};
// Pulls macro-generated client module from `lib`
use tarpc_example::WorldClient;

// Clap helps parse command line arguments
#[derive(Parser)]
struct Flags {
    /// Sets the server address to connect to.
    #[clap(long)]
    port: u16,
    /// Sets the name to say hello to.
    #[clap(long)]
    name: String,
}

// We use anyhow::Result<()> to handle any kind of error that might occur.
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let flags = Flags::parse();
    let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), flags.port);

    let mut transport = tarpc::serde_transport::tcp::connect(server_addr, Json::default);
    transport.config_mut().max_frame_length(usize::MAX);

    // WorldClient is generated by the service attribute. It has a constructor `new` that takes a
    // config and any Transport as input.
    let client = WorldClient::new(client::Config::default(), transport.await?).spawn();

    let hello = client
        .hello(context::current(), format!("{}", flags.name))
        .await;

    match hello {
        Ok(hello) => println!("Response: {hello:?}"),
        Err(e) => println!("Error: {:?}", anyhow::Error::from(e)),
    }

    Ok(())
}
